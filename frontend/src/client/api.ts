/* tslint:disable */
/* eslint-disable */
/**
 * AIBrush API
 * Orchestration backend for AI Brush
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: wolfgangmeyers@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreateImageInput
 */
export interface CreateImageInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateImageInput
     */
    phrases?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    iterations?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    parent?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    encoded_image?: string;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    created_at: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    created_by: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    updated_at: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    phrases: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    parent: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    iterations: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    current_iterations: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    score: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    status: ImageStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ImageStatusEnum {
    Pending = 'pending',
    Processing = 'processing',
    Completed = 'completed',
    Saved = 'saved'
}

/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageList
     */
    images?: Array<Image>;
}
/**
 * 
 * @export
 * @interface LoginInput
 */
export interface LoginInput {
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface LoginResult
 */
export interface LoginResult {
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface RefreshLoginInput
 */
export interface RefreshLoginInput {
    /**
     * 
     * @type {string}
     * @memberof RefreshLoginInput
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface UpdateImageInput
 */
export interface UpdateImageInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    current_iterations?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateImageInput
     */
    phrases?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    status?: UpdateImageInputStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    encoded_image?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateImageInputStatusEnum {
    Pending = 'pending',
    Processing = 'processing',
    Completed = 'completed',
    Saved = 'saved'
}

/**
 * 
 * @export
 * @interface VerifyLoginInput
 */
export interface VerifyLoginInput {
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    code?: string;
}

/**
 * AIBrushApi - axios parameter creator
 * @export
 */
export const AIBrushApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage: async (createImageInput?: CreateImageInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteImage', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {'thumbnail' | 'image'} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage: async (id: string, download?: 'thumbnail' | 'image', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImage', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageData', 'id', id)
            const localVarPath = `/images/{id}/image.jpg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getThumbnailData', 'id', id)
            const localVarPath = `/images/{id}/thumbnail.jpg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages: async (cursor?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInput?: LoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processImage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshLoginInput?: RefreshLoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: async (id: string, updateImageInput?: UpdateImageInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImage', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (verifyLoginInput?: VerifyLoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIBrushApi - functional programming interface
 * @export
 */
export const AIBrushApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIBrushApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImage(createImageInput?: CreateImageInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImage(createImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {'thumbnail' | 'image'} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImage(id: string, download?: 'thumbnail' | 'image', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(id, download, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThumbnailData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThumbnailData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImages(cursor?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImages(cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInput?: LoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processImage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processImage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshLoginInput?: RefreshLoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImage(id, updateImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(verifyLoginInput?: VerifyLoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(verifyLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AIBrushApi - factory interface
 * @export
 */
export const AIBrushApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIBrushApiFp(configuration)
    return {
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageInput?: CreateImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.createImage(createImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {'thumbnail' | 'image'} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage(id: string, download?: 'thumbnail' | 'image', options?: any): AxiosPromise<Image> {
            return localVarFp.getImage(id, download, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getImageData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getThumbnailData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages(cursor?: number, options?: any): AxiosPromise<ImageList> {
            return localVarFp.listImages(cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInput?: LoginInput, options?: any): AxiosPromise<void> {
            return localVarFp.login(loginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processImage(options?: any): AxiosPromise<Image> {
            return localVarFp.processImage(options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshLoginInput?: RefreshLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.refresh(refreshLoginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.updateImage(id, updateImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(verifyLoginInput?: VerifyLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.verify(verifyLoginInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIBrushApi - object-oriented interface
 * @export
 * @class AIBrushApi
 * @extends {BaseAPI}
 */
export class AIBrushApi extends BaseAPI {
    /**
     * Create a new image
     * @param {CreateImageInput} [createImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createImage(createImageInput?: CreateImageInput, options?: any) {
        return AIBrushApiFp(this.configuration).createImage(createImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a saved image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteImage(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).deleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a saved image by id
     * @param {string} id 
     * @param {'thumbnail' | 'image'} [download] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImage(id: string, download?: 'thumbnail' | 'image', options?: any) {
        return AIBrushApiFp(this.configuration).getImage(id, download, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary image data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getImageData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary thumbnail data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getThumbnailData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getThumbnailData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of saved images
     * @param {number} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listImages(cursor?: number, options?: any) {
        return AIBrushApiFp(this.configuration).listImages(cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login by email
     * @param {LoginInput} [loginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public login(loginInput?: LoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).login(loginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the next pending image and set its status to processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public processImage(options?: any) {
        return AIBrushApiFp(this.configuration).processImage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh Login code
     * @param {RefreshLoginInput} [refreshLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public refresh(refreshLoginInput?: RefreshLoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).refresh(refreshLoginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a saved image
     * @param {string} id 
     * @param {UpdateImageInput} [updateImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any) {
        return AIBrushApiFp(this.configuration).updateImage(id, updateImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify Login code
     * @param {VerifyLoginInput} [verifyLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public verify(verifyLoginInput?: VerifyLoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).verify(verifyLoginInput, options).then((request) => request(this.axios, this.basePath));
    }
}


