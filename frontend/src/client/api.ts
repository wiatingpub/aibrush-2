/* tslint:disable */
/* eslint-disable */
/**
 * AIBrush API
 * Orchestration backend for AI Brush
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: wolfgangmeyers@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AssetsUrl
 */
export interface AssetsUrl {
    /**
     * 
     * @type {string}
     * @memberof AssetsUrl
     */
    assets_url: string;
}
/**
 * 
 * @export
 * @interface CreateImageInput
 */
export interface CreateImageInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateImageInput
     */
    phrases?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateImageInput
     */
    negative_phrases?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    iterations?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    parent?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    encoded_image?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    encoded_mask?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    encoded_npy?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    enable_video?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    enable_zoom?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    zoom_frequency?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    zoom_scale?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    zoom_shift_x?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    zoom_shift_y?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    model?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    glid_3_xl_skip_iterations?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    glid_3_xl_clip_guidance?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    glid_3_xl_clip_guidance_scale?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    height?: CreateImageInputHeightEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    width?: CreateImageInputWidthEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    uncrop_offset_x?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    uncrop_offset_y?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateImageInputHeightEnum {
    NUMBER_128 = 128,
    NUMBER_256 = 256,
    NUMBER_384 = 384,
    NUMBER_512 = 512,
    NUMBER_640 = 640,
    NUMBER_768 = 768,
    NUMBER_896 = 896,
    NUMBER_1024 = 1024
}
/**
    * @export
    * @enum {string}
    */
export enum CreateImageInputWidthEnum {
    NUMBER_128 = 128,
    NUMBER_256 = 256,
    NUMBER_384 = 384,
    NUMBER_512 = 512,
    NUMBER_640 = 640,
    NUMBER_768 = 768,
    NUMBER_896 = 896,
    NUMBER_1024 = 1024
}

/**
 * 
 * @export
 * @interface CreateServiceAccountInput
 */
export interface CreateServiceAccountInput {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceAccountInput
     */
    type?: CreateServiceAccountInputTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateServiceAccountInputTypeEnum {
    Public = 'public',
    Private = 'private'
}

/**
 * 
 * @export
 * @interface CreateSuggestionsJobInput
 */
export interface CreateSuggestionsJobInput {
    /**
     * 
     * @type {string}
     * @memberof CreateSuggestionsJobInput
     */
    seed_id?: string;
}
/**
 * 
 * @export
 * @interface CreateSvgJobInput
 */
export interface CreateSvgJobInput {
    /**
     * 
     * @type {string}
     * @memberof CreateSvgJobInput
     */
    image_id?: string;
}
/**
 * 
 * @export
 * @interface CreateWorkflowEventInput
 */
export interface CreateWorkflowEventInput {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowEventInput
     */
    workflow_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowEventInput
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface CreateWorkflowInput
 */
export interface CreateWorkflowInput {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowInput
     */
    workflow_type: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowInput
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowInput
     */
    config_json: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowInput
     */
    data_json: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorkflowInput
     */
    is_active: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowInput
     */
    state: string;
    /**
     * 
     * @type {number}
     * @memberof CreateWorkflowInput
     */
    execution_delay: number;
}
/**
 * 
 * @export
 * @interface FeatureList
 */
export interface FeatureList {
    /**
     * 
     * @type {string}
     * @memberof FeatureList
     */
    terms_uri?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureList
     */
    privacy_uri?: string;
}
/**
 * 
 * @export
 * @interface Healthcheck
 */
export interface Healthcheck {
    /**
     * 
     * @type {string}
     * @memberof Healthcheck
     */
    status?: HealthcheckStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum HealthcheckStatusEnum {
    Ok = 'ok'
}

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    created_at: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    created_by: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    updated_at: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    phrases: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    negative_phrases: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    parent: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    iterations: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    current_iterations: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    score: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    negative_score: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    status: ImageStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    enable_video: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    enable_zoom?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    zoom_frequency?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    zoom_scale?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    zoom_shift_x?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    zoom_shift_y?: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    model: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    glid_3_xl_skip_iterations?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    glid_3_xl_clip_guidance?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    glid_3_xl_clip_guidance_scale?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    width?: ImageWidthEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    height?: ImageHeightEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    uncrop_offset_x?: ImageUncropOffsetXEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    uncrop_offset_y?: ImageUncropOffsetYEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ImageStatusEnum {
    Pending = 'pending',
    Processing = 'processing',
    Completed = 'completed',
    Saved = 'saved',
    Error = 'error'
}
/**
    * @export
    * @enum {string}
    */
export enum ImageWidthEnum {
    NUMBER_128 = 128,
    NUMBER_256 = 256,
    NUMBER_384 = 384,
    NUMBER_512 = 512,
    NUMBER_640 = 640,
    NUMBER_768 = 768,
    NUMBER_896 = 896,
    NUMBER_1024 = 1024
}
/**
    * @export
    * @enum {string}
    */
export enum ImageHeightEnum {
    NUMBER_128 = 128,
    NUMBER_256 = 256,
    NUMBER_384 = 384,
    NUMBER_512 = 512,
    NUMBER_640 = 640,
    NUMBER_768 = 768,
    NUMBER_896 = 896,
    NUMBER_1024 = 1024
}
/**
    * @export
    * @enum {string}
    */
export enum ImageUncropOffsetXEnum {
    NUMBER_MINUS_896 = -896,
    NUMBER_MINUS_768 = -768,
    NUMBER_MINUS_640 = -640,
    NUMBER_MINUS_512 = -512,
    NUMBER_MINUS_384 = -384,
    NUMBER_MINUS_256 = -256,
    NUMBER_MINUS_128 = -128,
    NUMBER_0 = 0,
    NUMBER_128 = 128,
    NUMBER_256 = 256,
    NUMBER_384 = 384,
    NUMBER_512 = 512,
    NUMBER_640 = 640,
    NUMBER_768 = 768,
    NUMBER_896 = 896
}
/**
    * @export
    * @enum {string}
    */
export enum ImageUncropOffsetYEnum {
    NUMBER_MINUS_896 = -896,
    NUMBER_MINUS_768 = -768,
    NUMBER_MINUS_640 = -640,
    NUMBER_MINUS_512 = -512,
    NUMBER_MINUS_384 = -384,
    NUMBER_MINUS_256 = -256,
    NUMBER_MINUS_128 = -128,
    NUMBER_0 = 0,
    NUMBER_128 = 128,
    NUMBER_256 = 256,
    NUMBER_384 = 384,
    NUMBER_512 = 512,
    NUMBER_640 = 640,
    NUMBER_768 = 768,
    NUMBER_896 = 896
}

/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageList
     */
    images?: Array<Image>;
}
/**
 * 
 * @export
 * @interface InviteCode
 */
export interface InviteCode {
    /**
     * 
     * @type {string}
     * @memberof InviteCode
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteCode
     */
    created_at?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteCode
     */
    created_by?: string;
}
/**
 * 
 * @export
 * @interface IsAdminResponse
 */
export interface IsAdminResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IsAdminResponse
     */
    is_admin?: boolean;
}
/**
 * 
 * @export
 * @interface LoginInput
 */
export interface LoginInput {
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    invite_code?: string;
}
/**
 * 
 * @export
 * @interface LoginResult
 */
export interface LoginResult {
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface ProcessImageInput
 */
export interface ProcessImageInput {
    /**
     * 
     * @type {boolean}
     * @memberof ProcessImageInput
     */
    zoom_supported: boolean;
}
/**
 * 
 * @export
 * @interface RefreshLoginInput
 */
export interface RefreshLoginInput {
    /**
     * 
     * @type {string}
     * @memberof RefreshLoginInput
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface SuggestionSeed
 */
export interface SuggestionSeed {
    /**
     * 
     * @type {string}
     * @memberof SuggestionSeed
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionSeed
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionSeed
     */
    description: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SuggestionSeed
     */
    items: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SuggestionSeed
     */
    created_by: string;
}
/**
 * 
 * @export
 * @interface SuggestionSeedInput
 */
export interface SuggestionSeedInput {
    /**
     * 
     * @type {string}
     * @memberof SuggestionSeedInput
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionSeedInput
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SuggestionSeedInput
     */
    items: Array<string>;
}
/**
 * 
 * @export
 * @interface SuggestionSeedList
 */
export interface SuggestionSeedList {
    /**
     * 
     * @type {Array<SuggestionSeed>}
     * @memberof SuggestionSeedList
     */
    suggestionSeeds: Array<SuggestionSeed>;
}
/**
 * 
 * @export
 * @interface SuggestionsJob
 */
export interface SuggestionsJob {
    /**
     * 
     * @type {string}
     * @memberof SuggestionsJob
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionsJob
     */
    created_by: string;
    /**
     * 
     * @type {number}
     * @memberof SuggestionsJob
     */
    created_at: number;
    /**
     * 
     * @type {number}
     * @memberof SuggestionsJob
     */
    updated_at: number;
    /**
     * 
     * @type {string}
     * @memberof SuggestionsJob
     */
    seed_id: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionsJob
     */
    status: SuggestionsJobStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof SuggestionsJob
     */
    result: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum SuggestionsJobStatusEnum {
    Pending = 'pending',
    Processing = 'processing',
    Completed = 'completed',
    Saved = 'saved'
}

/**
 * 
 * @export
 * @interface SuggestionsJobList
 */
export interface SuggestionsJobList {
    /**
     * 
     * @type {Array<SuggestionsJob>}
     * @memberof SuggestionsJobList
     */
    suggestionsJobs?: Array<SuggestionsJob>;
}
/**
 * 
 * @export
 * @interface SvgJob
 */
export interface SvgJob {
    /**
     * 
     * @type {string}
     * @memberof SvgJob
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SvgJob
     */
    created_by: string;
    /**
     * 
     * @type {number}
     * @memberof SvgJob
     */
    created_at: number;
    /**
     * 
     * @type {number}
     * @memberof SvgJob
     */
    updated_at: number;
    /**
     * 
     * @type {string}
     * @memberof SvgJob
     */
    image_id: string;
    /**
     * 
     * @type {string}
     * @memberof SvgJob
     */
    status: SvgJobStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SvgJobStatusEnum {
    Pending = 'pending',
    Processing = 'processing',
    Completed = 'completed'
}

/**
 * 
 * @export
 * @interface UpdateImageInput
 */
export interface UpdateImageInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    current_iterations?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    status?: UpdateImageInputStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    encoded_image?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    encoded_npy?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    score?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    negative_score?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateImageInputStatusEnum {
    Pending = 'pending',
    Processing = 'processing',
    Completed = 'completed',
    Saved = 'saved'
}

/**
 * 
 * @export
 * @interface UpdateSuggestionsJobInput
 */
export interface UpdateSuggestionsJobInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateSuggestionsJobInput
     */
    status?: UpdateSuggestionsJobInputStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSuggestionsJobInput
     */
    result?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateSuggestionsJobInputStatusEnum {
    Pending = 'pending',
    Processing = 'processing',
    Completed = 'completed',
    Saved = 'saved'
}

/**
 * 
 * @export
 * @interface UpdateSvgJobInput
 */
export interface UpdateSvgJobInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateSvgJobInput
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface UpdateWorkflowInput
 */
export interface UpdateWorkflowInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkflowInput
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkflowInput
     */
    data_json?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkflowInput
     */
    config_json?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorkflowInput
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkflowInput
     */
    state?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateWorkflowInput
     */
    execution_delay?: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface VerifyLoginInput
 */
export interface VerifyLoginInput {
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    created_by: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    workflow_type: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    config_json: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    data_json: string;
    /**
     * 
     * @type {boolean}
     * @memberof Workflow
     */
    is_active: boolean;
    /**
     * 
     * @type {number}
     * @memberof Workflow
     */
    execution_delay: number;
    /**
     * 
     * @type {number}
     * @memberof Workflow
     */
    next_execution: number;
}
/**
 * 
 * @export
 * @interface WorkflowEvent
 */
export interface WorkflowEvent {
    /**
     * 
     * @type {string}
     * @memberof WorkflowEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEvent
     */
    workflow_id?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowEvent
     */
    created_at?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEvent
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface WorkflowEventList
 */
export interface WorkflowEventList {
    /**
     * 
     * @type {Array<WorkflowEvent>}
     * @memberof WorkflowEventList
     */
    workflowEvents: Array<WorkflowEvent>;
}
/**
 * 
 * @export
 * @interface WorkflowList
 */
export interface WorkflowList {
    /**
     * 
     * @type {Array<Workflow>}
     * @memberof WorkflowList
     */
    workflows: Array<Workflow>;
}

/**
 * AIBrushApi - axios parameter creator
 * @export
 */
export const AIBrushApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage: async (createImageInput?: CreateImageInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteCode: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount: async (createServiceAccountInput?: CreateServiceAccountInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/service-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceAccountInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new suggestion seed
         * @param {SuggestionSeedInput} [suggestionSeedInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSuggestionSeed: async (suggestionSeedInput?: SuggestionSeedInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/suggestion-seeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestionSeedInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new suggestions job
         * @param {CreateSuggestionsJobInput} [createSuggestionsJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSuggestionsJob: async (createSuggestionsJobInput?: CreateSuggestionsJobInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/suggestions-jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSuggestionsJobInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new svg job
         * @param {CreateSvgJobInput} [createSvgJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSvgJob: async (createSvgJobInput?: CreateSvgJobInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/svg-jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSvgJobInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new workflow
         * @param {CreateWorkflowInput} [createWorkflowInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: async (createWorkflowInput?: CreateWorkflowInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new workflow event
         * @param {string} workflowId 
         * @param {CreateWorkflowEventInput} [createWorkflowEventInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowEvent: async (workflowId: string, createWorkflowEventInput?: CreateWorkflowEventInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('createWorkflowEvent', 'workflowId', workflowId)
            const localVarPath = `/api/workflows/{workflow_id}/events`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowEventInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a suggestion seed
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSuggestionSeed: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSuggestionSeed', 'id', id)
            const localVarPath = `/api/suggestion-seeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a suggestions job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSuggestionsJob: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSuggestionsJob', 'id', id)
            const localVarPath = `/api/suggestions-jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a svg job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSvgJob: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSvgJob', 'id', id)
            const localVarPath = `/api/svg-jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflow', 'workflowId', workflowId)
            const localVarPath = `/api/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsUrl: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/assets-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageData', 'id', id)
            const localVarPath = `/api/images/{id}.image.jpg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaskData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMaskData', 'id', id)
            const localVarPath = `/api/images/{id}.mask.jpg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpyData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNpyData', 'id', id)
            const localVarPath = `/api/images/{id}.npy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a suggestion seed by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestionSeed: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSuggestionSeed', 'id', id)
            const localVarPath = `/api/suggestion-seeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a suggestions job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestionsJob: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSuggestionsJob', 'id', id)
            const localVarPath = `/api/suggestions-jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a svg job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSvgJob: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSvgJob', 'id', id)
            const localVarPath = `/api/svg-jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a svg job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSvgJobResult: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSvgJobResult', 'id', id)
            const localVarPath = `/api/svg-jobs/{id}/result.svg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getThumbnailData', 'id', id)
            const localVarPath = `/api/images/{id}.thumbnail.jpg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary video data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVideoData', 'id', id)
            const localVarPath = `/api/images/{id}.mp4`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: async (workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflow', 'workflowId', workflowId)
            const localVarPath = `/api/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the workflow events
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowEvents: async (workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowEvents', 'workflowId', workflowId)
            const localVarPath = `/api/workflows/{workflow_id}/events`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/is-admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages: async (cursor?: number, limit?: number, direction?: 'asc' | 'desc', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of suggestion seeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuggestionSeeds: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/suggestion-seeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of suggestions jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuggestionsJobs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/suggestions-jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInput?: LoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processImage: async (processImageInput?: ProcessImageInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/process-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a suggestions job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processSuggestionsJob: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/process-suggestion-job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a svg job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processSvgJob: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/process-svg-job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the next pending workflow and set its status to processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processWorkflow: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/process-workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshLoginInput?: RefreshLoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: async (id: string, updateImageInput?: UpdateImageInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a suggestion seed
         * @param {string} id 
         * @param {SuggestionSeedInput} [suggestionSeedInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuggestionSeed: async (id: string, suggestionSeedInput?: SuggestionSeedInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSuggestionSeed', 'id', id)
            const localVarPath = `/api/suggestion-seeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestionSeedInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a suggestions job
         * @param {string} id 
         * @param {UpdateSuggestionsJobInput} [updateSuggestionsJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuggestionsJob: async (id: string, updateSuggestionsJobInput?: UpdateSuggestionsJobInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSuggestionsJob', 'id', id)
            const localVarPath = `/api/suggestions-jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSuggestionsJobInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a svg job
         * @param {string} id 
         * @param {UpdateSvgJobInput} [updateSvgJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSvgJob: async (id: string, updateSvgJobInput?: UpdateSvgJobInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSvgJob', 'id', id)
            const localVarPath = `/api/svg-jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSvgJobInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the video data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoData: async (id: string, body?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVideoData', 'id', id)
            const localVarPath = `/api/images/{id}.mp4`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'video/mp4';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the workflow
         * @param {string} workflowId 
         * @param {UpdateWorkflowInput} [updateWorkflowInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow: async (workflowId: string, updateWorkflowInput?: UpdateWorkflowInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('updateWorkflow', 'workflowId', workflowId)
            const localVarPath = `/api/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkflowInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (verifyLoginInput?: VerifyLoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIBrushApi - functional programming interface
 * @export
 */
export const AIBrushApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIBrushApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImage(createImageInput?: CreateImageInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImage(createImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteCode(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteCode(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAccount(createServiceAccountInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new suggestion seed
         * @param {SuggestionSeedInput} [suggestionSeedInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSuggestionSeed(suggestionSeedInput?: SuggestionSeedInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionSeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSuggestionSeed(suggestionSeedInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new suggestions job
         * @param {CreateSuggestionsJobInput} [createSuggestionsJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSuggestionsJob(createSuggestionsJobInput?: CreateSuggestionsJobInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionsJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSuggestionsJob(createSuggestionsJobInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new svg job
         * @param {CreateSvgJobInput} [createSvgJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSvgJob(createSvgJobInput?: CreateSvgJobInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SvgJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSvgJob(createSvgJobInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new workflow
         * @param {CreateWorkflowInput} [createWorkflowInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflow(createWorkflowInput?: CreateWorkflowInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflow(createWorkflowInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new workflow event
         * @param {string} workflowId 
         * @param {CreateWorkflowEventInput} [createWorkflowEventInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowEvent(workflowId: string, createWorkflowEventInput?: CreateWorkflowEventInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowEvent(workflowId, createWorkflowEventInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a suggestion seed
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSuggestionSeed(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSuggestionSeed(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a suggestions job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSuggestionsJob(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSuggestionsJob(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a svg job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSvgJob(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSvgJob(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(workflowId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetsUrl(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetsUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetsUrl(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaskData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaskData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpyData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNpyData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a suggestion seed by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestionSeed(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionSeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestionSeed(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a suggestions job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestionsJob(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionsJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestionsJob(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a svg job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSvgJob(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SvgJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSvgJob(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a svg job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSvgJobResult(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSvgJobResult(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThumbnailData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThumbnailData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary video data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVideoData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflow(workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflow(workflowId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the workflow events
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowEvents(workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowEvents(workflowId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflows(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflows(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheck(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Healthcheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthcheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsAdminResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImages(cursor?: number, limit?: number, direction?: 'asc' | 'desc', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImages(cursor, limit, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of suggestion seeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSuggestionSeeds(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionSeedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSuggestionSeeds(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of suggestions jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSuggestionsJobs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionsJobList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSuggestionsJobs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInput?: LoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processImage(processImageInput?: ProcessImageInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processImage(processImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process a suggestions job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processSuggestionsJob(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionsJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processSuggestionsJob(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process a svg job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processSvgJob(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SvgJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processSvgJob(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the next pending workflow and set its status to processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processWorkflow(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processWorkflow(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshLoginInput?: RefreshLoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImage(id, updateImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a suggestion seed
         * @param {string} id 
         * @param {SuggestionSeedInput} [suggestionSeedInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuggestionSeed(id: string, suggestionSeedInput?: SuggestionSeedInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionSeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSuggestionSeed(id, suggestionSeedInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a suggestions job
         * @param {string} id 
         * @param {UpdateSuggestionsJobInput} [updateSuggestionsJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuggestionsJob(id: string, updateSuggestionsJobInput?: UpdateSuggestionsJobInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionsJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSuggestionsJob(id, updateSuggestionsJobInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a svg job
         * @param {string} id 
         * @param {UpdateSvgJobInput} [updateSvgJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSvgJob(id: string, updateSvgJobInput?: UpdateSvgJobInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SvgJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSvgJob(id, updateSvgJobInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the video data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVideoData(id: string, body?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVideoData(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the workflow
         * @param {string} workflowId 
         * @param {UpdateWorkflowInput} [updateWorkflowInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflow(workflowId: string, updateWorkflowInput?: UpdateWorkflowInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflow(workflowId, updateWorkflowInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(verifyLoginInput?: VerifyLoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(verifyLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AIBrushApi - factory interface
 * @export
 */
export const AIBrushApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIBrushApiFp(configuration)
    return {
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageInput?: CreateImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.createImage(createImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteCode(options?: any): AxiosPromise<InviteCode> {
            return localVarFp.createInviteCode(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.createServiceAccount(createServiceAccountInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new suggestion seed
         * @param {SuggestionSeedInput} [suggestionSeedInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSuggestionSeed(suggestionSeedInput?: SuggestionSeedInput, options?: any): AxiosPromise<SuggestionSeed> {
            return localVarFp.createSuggestionSeed(suggestionSeedInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new suggestions job
         * @param {CreateSuggestionsJobInput} [createSuggestionsJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSuggestionsJob(createSuggestionsJobInput?: CreateSuggestionsJobInput, options?: any): AxiosPromise<SuggestionsJob> {
            return localVarFp.createSuggestionsJob(createSuggestionsJobInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new svg job
         * @param {CreateSvgJobInput} [createSvgJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSvgJob(createSvgJobInput?: CreateSvgJobInput, options?: any): AxiosPromise<SvgJob> {
            return localVarFp.createSvgJob(createSvgJobInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new workflow
         * @param {CreateWorkflowInput} [createWorkflowInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(createWorkflowInput?: CreateWorkflowInput, options?: any): AxiosPromise<Workflow> {
            return localVarFp.createWorkflow(createWorkflowInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new workflow event
         * @param {string} workflowId 
         * @param {CreateWorkflowEventInput} [createWorkflowEventInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowEvent(workflowId: string, createWorkflowEventInput?: CreateWorkflowEventInput, options?: any): AxiosPromise<WorkflowEvent> {
            return localVarFp.createWorkflowEvent(workflowId, createWorkflowEventInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a suggestion seed
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSuggestionSeed(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSuggestionSeed(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a suggestions job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSuggestionsJob(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSuggestionsJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a svg job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSvgJob(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSvgJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(workflowId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflow(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsUrl(options?: any): AxiosPromise<AssetsUrl> {
            return localVarFp.getAssetsUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures(options?: any): AxiosPromise<FeatureList> {
            return localVarFp.getFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage(id: string, options?: any): AxiosPromise<Image> {
            return localVarFp.getImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getImageData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaskData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMaskData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpyData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getNpyData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a suggestion seed by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestionSeed(id: string, options?: any): AxiosPromise<SuggestionSeed> {
            return localVarFp.getSuggestionSeed(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a suggestions job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestionsJob(id: string, options?: any): AxiosPromise<SuggestionsJob> {
            return localVarFp.getSuggestionsJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a svg job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSvgJob(id: string, options?: any): AxiosPromise<SvgJob> {
            return localVarFp.getSvgJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a svg job by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSvgJobResult(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.getSvgJobResult(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getThumbnailData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary video data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getVideoData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(workflowId: string, options?: any): AxiosPromise<Workflow> {
            return localVarFp.getWorkflow(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the workflow events
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowEvents(workflowId: string, options?: any): AxiosPromise<WorkflowEventList> {
            return localVarFp.getWorkflowEvents(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows(options?: any): AxiosPromise<WorkflowList> {
            return localVarFp.getWorkflows(options).then((request) => request(axios, basePath));
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck(options?: any): AxiosPromise<Healthcheck> {
            return localVarFp.healthcheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAdmin(options?: any): AxiosPromise<IsAdminResponse> {
            return localVarFp.isAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages(cursor?: number, limit?: number, direction?: 'asc' | 'desc', options?: any): AxiosPromise<ImageList> {
            return localVarFp.listImages(cursor, limit, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of suggestion seeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuggestionSeeds(options?: any): AxiosPromise<SuggestionSeedList> {
            return localVarFp.listSuggestionSeeds(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of suggestions jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuggestionsJobs(options?: any): AxiosPromise<SuggestionsJobList> {
            return localVarFp.listSuggestionsJobs(options).then((request) => request(axios, basePath));
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInput?: LoginInput, options?: any): AxiosPromise<void> {
            return localVarFp.login(loginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processImage(processImageInput?: ProcessImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.processImage(processImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a suggestions job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processSuggestionsJob(options?: any): AxiosPromise<SuggestionsJob> {
            return localVarFp.processSuggestionsJob(options).then((request) => request(axios, basePath));
        },
        /**
         * Process a svg job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processSvgJob(options?: any): AxiosPromise<SvgJob> {
            return localVarFp.processSvgJob(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the next pending workflow and set its status to processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processWorkflow(options?: any): AxiosPromise<Workflow> {
            return localVarFp.processWorkflow(options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshLoginInput?: RefreshLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.refresh(refreshLoginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.updateImage(id, updateImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a suggestion seed
         * @param {string} id 
         * @param {SuggestionSeedInput} [suggestionSeedInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuggestionSeed(id: string, suggestionSeedInput?: SuggestionSeedInput, options?: any): AxiosPromise<SuggestionSeed> {
            return localVarFp.updateSuggestionSeed(id, suggestionSeedInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a suggestions job
         * @param {string} id 
         * @param {UpdateSuggestionsJobInput} [updateSuggestionsJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuggestionsJob(id: string, updateSuggestionsJobInput?: UpdateSuggestionsJobInput, options?: any): AxiosPromise<SuggestionsJob> {
            return localVarFp.updateSuggestionsJob(id, updateSuggestionsJobInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a svg job
         * @param {string} id 
         * @param {UpdateSvgJobInput} [updateSvgJobInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSvgJob(id: string, updateSvgJobInput?: UpdateSvgJobInput, options?: any): AxiosPromise<SvgJob> {
            return localVarFp.updateSvgJob(id, updateSvgJobInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the video data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoData(id: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.updateVideoData(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the workflow
         * @param {string} workflowId 
         * @param {UpdateWorkflowInput} [updateWorkflowInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(workflowId: string, updateWorkflowInput?: UpdateWorkflowInput, options?: any): AxiosPromise<Workflow> {
            return localVarFp.updateWorkflow(workflowId, updateWorkflowInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(verifyLoginInput?: VerifyLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.verify(verifyLoginInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIBrushApi - object-oriented interface
 * @export
 * @class AIBrushApi
 * @extends {BaseAPI}
 */
export class AIBrushApi extends BaseAPI {
    /**
     * Create a new image
     * @param {CreateImageInput} [createImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createImage(createImageInput?: CreateImageInput, options?: any) {
        return AIBrushApiFp(this.configuration).createImage(createImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new invite code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createInviteCode(options?: any) {
        return AIBrushApiFp(this.configuration).createInviteCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a service account
     * @param {CreateServiceAccountInput} [createServiceAccountInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: any) {
        return AIBrushApiFp(this.configuration).createServiceAccount(createServiceAccountInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new suggestion seed
     * @param {SuggestionSeedInput} [suggestionSeedInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createSuggestionSeed(suggestionSeedInput?: SuggestionSeedInput, options?: any) {
        return AIBrushApiFp(this.configuration).createSuggestionSeed(suggestionSeedInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new suggestions job
     * @param {CreateSuggestionsJobInput} [createSuggestionsJobInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createSuggestionsJob(createSuggestionsJobInput?: CreateSuggestionsJobInput, options?: any) {
        return AIBrushApiFp(this.configuration).createSuggestionsJob(createSuggestionsJobInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new svg job
     * @param {CreateSvgJobInput} [createSvgJobInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createSvgJob(createSvgJobInput?: CreateSvgJobInput, options?: any) {
        return AIBrushApiFp(this.configuration).createSvgJob(createSvgJobInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new workflow
     * @param {CreateWorkflowInput} [createWorkflowInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createWorkflow(createWorkflowInput?: CreateWorkflowInput, options?: any) {
        return AIBrushApiFp(this.configuration).createWorkflow(createWorkflowInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new workflow event
     * @param {string} workflowId 
     * @param {CreateWorkflowEventInput} [createWorkflowEventInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createWorkflowEvent(workflowId: string, createWorkflowEventInput?: CreateWorkflowEventInput, options?: any) {
        return AIBrushApiFp(this.configuration).createWorkflowEvent(workflowId, createWorkflowEventInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a saved image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteImage(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).deleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a suggestion seed
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteSuggestionSeed(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).deleteSuggestionSeed(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a suggestions job
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteSuggestionsJob(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).deleteSuggestionsJob(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a svg job
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteSvgJob(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).deleteSvgJob(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteWorkflow(workflowId: string, options?: any) {
        return AIBrushApiFp(this.configuration).deleteWorkflow(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the assets url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getAssetsUrl(options?: any) {
        return AIBrushApiFp(this.configuration).getAssetsUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getFeatures(options?: any) {
        return AIBrushApiFp(this.configuration).getFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a saved image by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImage(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary image data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getImageData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary mask data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getMaskData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getMaskData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary image data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getNpyData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getNpyData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a suggestion seed by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getSuggestionSeed(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getSuggestionSeed(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a suggestions job by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getSuggestionsJob(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getSuggestionsJob(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a svg job by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getSvgJob(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getSvgJob(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a svg job by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getSvgJobResult(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getSvgJobResult(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary thumbnail data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getThumbnailData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getThumbnailData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary video data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getVideoData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getVideoData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getWorkflow(workflowId: string, options?: any) {
        return AIBrushApiFp(this.configuration).getWorkflow(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the workflow events
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getWorkflowEvents(workflowId: string, options?: any) {
        return AIBrushApiFp(this.configuration).getWorkflowEvents(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the workflows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getWorkflows(options?: any) {
        return AIBrushApiFp(this.configuration).getWorkflows(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public healthcheck(options?: any) {
        return AIBrushApiFp(this.configuration).healthcheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the user is admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public isAdmin(options?: any) {
        return AIBrushApiFp(this.configuration).isAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of saved images
     * @param {number} [cursor] 
     * @param {number} [limit] 
     * @param {'asc' | 'desc'} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listImages(cursor?: number, limit?: number, direction?: 'asc' | 'desc', options?: any) {
        return AIBrushApiFp(this.configuration).listImages(cursor, limit, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of suggestion seeds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listSuggestionSeeds(options?: any) {
        return AIBrushApiFp(this.configuration).listSuggestionSeeds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of suggestions jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listSuggestionsJobs(options?: any) {
        return AIBrushApiFp(this.configuration).listSuggestionsJobs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login by email
     * @param {LoginInput} [loginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public login(loginInput?: LoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).login(loginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the next pending image and set its status to processing.
     * @param {ProcessImageInput} [processImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public processImage(processImageInput?: ProcessImageInput, options?: any) {
        return AIBrushApiFp(this.configuration).processImage(processImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a suggestions job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public processSuggestionsJob(options?: any) {
        return AIBrushApiFp(this.configuration).processSuggestionsJob(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a svg job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public processSvgJob(options?: any) {
        return AIBrushApiFp(this.configuration).processSvgJob(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the next pending workflow and set its status to processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public processWorkflow(options?: any) {
        return AIBrushApiFp(this.configuration).processWorkflow(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh Login code
     * @param {RefreshLoginInput} [refreshLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public refresh(refreshLoginInput?: RefreshLoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).refresh(refreshLoginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a saved image
     * @param {string} id 
     * @param {UpdateImageInput} [updateImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any) {
        return AIBrushApiFp(this.configuration).updateImage(id, updateImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a suggestion seed
     * @param {string} id 
     * @param {SuggestionSeedInput} [suggestionSeedInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateSuggestionSeed(id: string, suggestionSeedInput?: SuggestionSeedInput, options?: any) {
        return AIBrushApiFp(this.configuration).updateSuggestionSeed(id, suggestionSeedInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a suggestions job
     * @param {string} id 
     * @param {UpdateSuggestionsJobInput} [updateSuggestionsJobInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateSuggestionsJob(id: string, updateSuggestionsJobInput?: UpdateSuggestionsJobInput, options?: any) {
        return AIBrushApiFp(this.configuration).updateSuggestionsJob(id, updateSuggestionsJobInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a svg job
     * @param {string} id 
     * @param {UpdateSvgJobInput} [updateSvgJobInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateSvgJob(id: string, updateSvgJobInput?: UpdateSvgJobInput, options?: any) {
        return AIBrushApiFp(this.configuration).updateSvgJob(id, updateSvgJobInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the video data
     * @param {string} id 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateVideoData(id: string, body?: any, options?: any) {
        return AIBrushApiFp(this.configuration).updateVideoData(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the workflow
     * @param {string} workflowId 
     * @param {UpdateWorkflowInput} [updateWorkflowInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateWorkflow(workflowId: string, updateWorkflowInput?: UpdateWorkflowInput, options?: any) {
        return AIBrushApiFp(this.configuration).updateWorkflow(workflowId, updateWorkflowInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify Login code
     * @param {VerifyLoginInput} [verifyLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public verify(verifyLoginInput?: VerifyLoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).verify(verifyLoginInput, options).then((request) => request(this.axios, this.basePath));
    }
}


