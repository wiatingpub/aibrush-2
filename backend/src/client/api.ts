/* tslint:disable */
/* eslint-disable */
/**
 * AIBrush API
 * Orchestration backend for AI Brush
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: wolfgangmeyers@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddMetricItem
 */
export interface AddMetricItem {
    /**
     * 
     * @type {string}
     * @memberof AddMetricItem
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AddMetricItem
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof AddMetricItem
     */
    'type': AddMetricItemTypeEnum;
    /**
     * 
     * @type {Array<MetricAttribute>}
     * @memberof AddMetricItem
     */
    'attributes': Array<MetricAttribute>;
}

export const AddMetricItemTypeEnum = {
    Gauge: 'gauge',
    Count: 'count'
} as const;

export type AddMetricItemTypeEnum = typeof AddMetricItemTypeEnum[keyof typeof AddMetricItemTypeEnum];

/**
 * 
 * @export
 * @interface AddMetricsInput
 */
export interface AddMetricsInput {
    /**
     * 
     * @type {Array<AddMetricItem>}
     * @memberof AddMetricsInput
     */
    'metrics': Array<AddMetricItem>;
}
/**
 * 
 * @export
 * @interface AssetsUrl
 */
export interface AssetsUrl {
    /**
     * 
     * @type {string}
     * @memberof AssetsUrl
     */
    'assets_url': string;
}
/**
 * 
 * @export
 * @interface CreateImageInput
 */
export interface CreateImageInput {
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'status'?: CreateImageInputStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateImageInput
     */
    'phrases'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateImageInput
     */
    'negative_phrases'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'label'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'iterations'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'parent'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'encoded_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'encoded_mask'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'encoded_npy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'enable_video'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'enable_zoom'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'zoom_frequency'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'zoom_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'zoom_shift_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'zoom_shift_y'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'model'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'glid_3_xl_skip_iterations'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'glid_3_xl_clip_guidance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'glid_3_xl_clip_guidance_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'height'?: CreateImageInputHeightEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'width'?: CreateImageInputWidthEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'uncrop_offset_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'uncrop_offset_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'stable_diffusion_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'nsfw'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'temporary'?: boolean;
}

export const CreateImageInputStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Saved: 'saved',
    Error: 'error'
} as const;

export type CreateImageInputStatusEnum = typeof CreateImageInputStatusEnum[keyof typeof CreateImageInputStatusEnum];
export const CreateImageInputHeightEnum = {
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896,
    NUMBER_1024: 1024
} as const;

export type CreateImageInputHeightEnum = typeof CreateImageInputHeightEnum[keyof typeof CreateImageInputHeightEnum];
export const CreateImageInputWidthEnum = {
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896,
    NUMBER_1024: 1024
} as const;

export type CreateImageInputWidthEnum = typeof CreateImageInputWidthEnum[keyof typeof CreateImageInputWidthEnum];

/**
 * 
 * @export
 * @interface CreateServiceAccountInput
 */
export interface CreateServiceAccountInput {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceAccountInput
     */
    'type'?: CreateServiceAccountInputTypeEnum;
}

export const CreateServiceAccountInputTypeEnum = {
    Public: 'public',
    Private: 'private'
} as const;

export type CreateServiceAccountInputTypeEnum = typeof CreateServiceAccountInputTypeEnum[keyof typeof CreateServiceAccountInputTypeEnum];

/**
 * 
 * @export
 * @interface FeatureList
 */
export interface FeatureList {
    /**
     * 
     * @type {string}
     * @memberof FeatureList
     */
    'terms_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureList
     */
    'privacy_uri'?: string;
}
/**
 * 
 * @export
 * @interface Healthcheck
 */
export interface Healthcheck {
    /**
     * 
     * @type {string}
     * @memberof Healthcheck
     */
    'status'?: HealthcheckStatusEnum;
}

export const HealthcheckStatusEnum = {
    Ok: 'ok'
} as const;

export type HealthcheckStatusEnum = typeof HealthcheckStatusEnum[keyof typeof HealthcheckStatusEnum];

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'created_by': string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'updated_at': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    'phrases': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    'negative_phrases': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'parent': string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'iterations': number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'current_iterations': number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'score': number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'negative_score': number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'status': ImageStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'enable_video': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'enable_zoom'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'zoom_frequency'?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'zoom_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'zoom_shift_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'zoom_shift_y'?: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'model': string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'glid_3_xl_skip_iterations'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'glid_3_xl_clip_guidance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'glid_3_xl_clip_guidance_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'width': ImageWidthEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'height': ImageHeightEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'uncrop_offset_x'?: ImageUncropOffsetXEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'uncrop_offset_y'?: ImageUncropOffsetYEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'stable_diffusion_strength': number;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'nsfw': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'temporary': boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'deleted_at'?: number;
}

export const ImageStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Saved: 'saved',
    Error: 'error'
} as const;

export type ImageStatusEnum = typeof ImageStatusEnum[keyof typeof ImageStatusEnum];
export const ImageWidthEnum = {
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896,
    NUMBER_1024: 1024
} as const;

export type ImageWidthEnum = typeof ImageWidthEnum[keyof typeof ImageWidthEnum];
export const ImageHeightEnum = {
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896,
    NUMBER_1024: 1024
} as const;

export type ImageHeightEnum = typeof ImageHeightEnum[keyof typeof ImageHeightEnum];
export const ImageUncropOffsetXEnum = {
    NUMBER_MINUS_896: -896,
    NUMBER_MINUS_768: -768,
    NUMBER_MINUS_640: -640,
    NUMBER_MINUS_512: -512,
    NUMBER_MINUS_384: -384,
    NUMBER_MINUS_256: -256,
    NUMBER_MINUS_128: -128,
    NUMBER_0: 0,
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896
} as const;

export type ImageUncropOffsetXEnum = typeof ImageUncropOffsetXEnum[keyof typeof ImageUncropOffsetXEnum];
export const ImageUncropOffsetYEnum = {
    NUMBER_MINUS_896: -896,
    NUMBER_MINUS_768: -768,
    NUMBER_MINUS_640: -640,
    NUMBER_MINUS_512: -512,
    NUMBER_MINUS_384: -384,
    NUMBER_MINUS_256: -256,
    NUMBER_MINUS_128: -128,
    NUMBER_0: 0,
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896
} as const;

export type ImageUncropOffsetYEnum = typeof ImageUncropOffsetYEnum[keyof typeof ImageUncropOffsetYEnum];

/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageList
     */
    'images'?: Array<Image>;
}
/**
 * 
 * @export
 * @interface InviteCode
 */
export interface InviteCode {
    /**
     * 
     * @type {string}
     * @memberof InviteCode
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteCode
     */
    'created_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteCode
     */
    'created_by'?: string;
}
/**
 * 
 * @export
 * @interface IsAdminResponse
 */
export interface IsAdminResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IsAdminResponse
     */
    'is_admin'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginInput
 */
export interface LoginInput {
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    'invite_code'?: string;
}
/**
 * 
 * @export
 * @interface LoginResult
 */
export interface LoginResult {
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface MetricAttribute
 */
export interface MetricAttribute {
    /**
     * 
     * @type {string}
     * @memberof MetricAttribute
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricAttribute
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ProcessImageInput
 */
export interface ProcessImageInput {
    /**
     * 
     * @type {boolean}
     * @memberof ProcessImageInput
     */
    'zoom_supported': boolean;
}
/**
 * 
 * @export
 * @interface RefreshLoginInput
 */
export interface RefreshLoginInput {
    /**
     * 
     * @type {string}
     * @memberof RefreshLoginInput
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface UpdateImageInput
 */
export interface UpdateImageInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    'label'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    'current_iterations'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    'status'?: UpdateImageInputStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    'encoded_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    'encoded_npy'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    'score'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    'negative_score'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateImageInput
     */
    'nsfw'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    'deleted_at'?: number | null;
}

export const UpdateImageInputStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Saved: 'saved',
    Error: 'error'
} as const;

export type UpdateImageInputStatusEnum = typeof UpdateImageInputStatusEnum[keyof typeof UpdateImageInputStatusEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface VerifyLoginInput
 */
export interface VerifyLoginInput {
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    'code'?: string;
}

/**
 * AIBrushApi - axios parameter creator
 * @export
 */
export const AIBrushApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetrics: async (addMetricsInput?: AddMetricsInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMetricsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage: async (createImageInput?: CreateImageInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteCode: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount: async (createServiceAccountInput?: CreateServiceAccountInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/service-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceAccountInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsUrl: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/assets-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageData', 'id', id)
            const localVarPath = `/api/images/{id}.image.jpg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaskData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMaskData', 'id', id)
            const localVarPath = `/api/images/{id}.mask.jpg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpyData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNpyData', 'id', id)
            const localVarPath = `/api/images/{id}.npy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getThumbnailData', 'id', id)
            const localVarPath = `/api/images/{id}.thumbnail.jpg`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary video data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVideoData', 'id', id)
            const localVarPath = `/api/images/{id}.mp4`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/is-admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages: async (cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInput?: LoginInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processImage: async (processImageInput?: ProcessImageInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/process-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshLoginInput?: RefreshLoginInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: async (id: string, updateImageInput?: UpdateImageInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the video data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoData: async (id: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVideoData', 'id', id)
            const localVarPath = `/api/images/{id}.mp4`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'video/mp4';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (verifyLoginInput?: VerifyLoginInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIBrushApi - functional programming interface
 * @export
 */
export const AIBrushApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIBrushApiAxiosParamCreator(configuration)
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetrics(addMetricsInput?: AddMetricsInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetrics(addMetricsInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImage(createImageInput?: CreateImageInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImage(createImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteCode(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteCode(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAccount(createServiceAccountInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetsUrl(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetsUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetsUrl(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaskData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaskData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpyData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNpyData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThumbnailData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThumbnailData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary video data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVideoData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Healthcheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthcheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsAdminResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImages(cursor, filter, limit, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInput?: LoginInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processImage(processImageInput?: ProcessImageInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processImage(processImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshLoginInput?: RefreshLoginInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImage(id: string, updateImageInput?: UpdateImageInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImage(id, updateImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the video data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVideoData(id: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVideoData(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(verifyLoginInput?: VerifyLoginInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(verifyLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AIBrushApi - factory interface
 * @export
 */
export const AIBrushApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIBrushApiFp(configuration)
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetrics(addMetricsInput?: AddMetricsInput, options?: any): AxiosPromise<void> {
            return localVarFp.addMetrics(addMetricsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageInput?: CreateImageInput, options?: any): AxiosPromise<ImageList> {
            return localVarFp.createImage(createImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteCode(options?: any): AxiosPromise<InviteCode> {
            return localVarFp.createInviteCode(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.createServiceAccount(createServiceAccountInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsUrl(options?: any): AxiosPromise<AssetsUrl> {
            return localVarFp.getAssetsUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures(options?: any): AxiosPromise<FeatureList> {
            return localVarFp.getFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage(id: string, options?: any): AxiosPromise<Image> {
            return localVarFp.getImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getImageData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaskData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMaskData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpyData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getNpyData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getThumbnailData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary video data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getVideoData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck(options?: any): AxiosPromise<Healthcheck> {
            return localVarFp.healthcheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAdmin(options?: any): AxiosPromise<IsAdminResponse> {
            return localVarFp.isAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: any): AxiosPromise<ImageList> {
            return localVarFp.listImages(cursor, filter, limit, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInput?: LoginInput, options?: any): AxiosPromise<void> {
            return localVarFp.login(loginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processImage(processImageInput?: ProcessImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.processImage(processImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshLoginInput?: RefreshLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.refresh(refreshLoginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.updateImage(id, updateImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the video data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoData(id: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.updateVideoData(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(verifyLoginInput?: VerifyLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.verify(verifyLoginInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIBrushApi - object-oriented interface
 * @export
 * @class AIBrushApi
 * @extends {BaseAPI}
 */
export class AIBrushApi extends BaseAPI {
    /**
     * Add Metrics
     * @param {AddMetricsInput} [addMetricsInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public addMetrics(addMetricsInput?: AddMetricsInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).addMetrics(addMetricsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new image
     * @param {CreateImageInput} [createImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createImage(createImageInput?: CreateImageInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).createImage(createImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new invite code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createInviteCode(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).createInviteCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a service account
     * @param {CreateServiceAccountInput} [createServiceAccountInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).createServiceAccount(createServiceAccountInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a saved image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteImage(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).deleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the assets url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getAssetsUrl(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getAssetsUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getFeatures(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a saved image by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImage(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary image data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageData(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getImageData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary mask data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getMaskData(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getMaskData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary image data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getNpyData(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getNpyData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary thumbnail data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getThumbnailData(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getThumbnailData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary video data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getVideoData(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getVideoData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public healthcheck(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).healthcheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the user is admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public isAdmin(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).isAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of saved images
     * @param {number} [cursor] 
     * @param {string} [filter] 
     * @param {number} [limit] 
     * @param {'asc' | 'desc'} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).listImages(cursor, filter, limit, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login by email
     * @param {LoginInput} [loginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public login(loginInput?: LoginInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).login(loginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the next pending image and set its status to processing.
     * @param {ProcessImageInput} [processImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public processImage(processImageInput?: ProcessImageInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).processImage(processImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh Login code
     * @param {RefreshLoginInput} [refreshLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public refresh(refreshLoginInput?: RefreshLoginInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).refresh(refreshLoginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a saved image
     * @param {string} id 
     * @param {UpdateImageInput} [updateImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateImage(id: string, updateImageInput?: UpdateImageInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).updateImage(id, updateImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the video data
     * @param {string} id 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateVideoData(id: string, body?: any, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).updateVideoData(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify Login code
     * @param {VerifyLoginInput} [verifyLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public verify(verifyLoginInput?: VerifyLoginInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).verify(verifyLoginInput, options).then((request) => request(this.axios, this.basePath));
    }
}


